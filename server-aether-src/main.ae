(fun create-message [version return-code payload]
  (let message 'INTP')
  (set message (+ message (byte-16-to-str version)))
  (set message (+ message (byte-16-to-str return-code)))
  (set message (+ message (byte-32-to-str (len payload))))
  (set message (+ message payload))
  message)

(if (< (len (get-args)) 3)
  (println 'ERROR: no routes were provided')
  (exit 1))

(fun join [parts]
  (fun join-rec [parts-left is-first]
    (if (&& parts-left (tail parts-left))
      (let accumulator (+ (head parts-left) (join-rec (tail parts-left) false)))
      (if is-first
        accumulator
       else
        (+ ':' accumulator))
     else
      ''))
  (join-rec parts true))

(fun parse-routes [args_left]
  (if args_left
    (let parts (split (head args_left) ':'))
    (let joined (join parts))
    (let bytecode (read-file (last parts)))
    (if (unit? bytecode)
      (print 'File ')
      (print (last parts)
      (println ' was not found')
      (exit 1)))

    (let route { route: joined bytecode: bytecode })
    (let routes (+ route (parse-routes (tail args_left))))
    (print 'INFO: initialized route ')
    (println (last parts))
    routes
   else
    []))

(let routes (parse-routes (tail (tail (get-args)))))

(let server (create-server 8080))
(if (unit? server)
  (println 'ERROR: failed to create server')
  (exit 1))

(while true
  (let client (accept-connection server 8080))
  (if (unit? client)
    (println 'ERROR: failed to accept new connection')
    (exit 1))

  (let request (receive client))
  (let response (create-message 1 0 (field (head routes) bytecode)))
  (send client response)
  (close-connection client))
